import {Command, flags} from '@oclif/command'
import cli from 'cli-ux'
const fs = require('fs-extra')
const chalk  = require('chalk')

export class AddEnvToBaseModule extends Command {

  static description = 'add environment aws infrastructure to the base app module'

  static examples = [
    `$ mssk base-module:add-env environment_name`,
  ]

  static args = [{
    name: 'env',
    required: true,
    description: 'environment name', // help description
  }]

  static flags = {
    help: flags.help({char: 'h'})
  }

  async run() {
    const {args, flags} = this.parse(AddEnvToBaseModule)

    const env = args.env

    const baseModuleInitiated = fs.pathExistsSync(`./mssk-properties.json`)
    if(!baseModuleInitiated) {
      return this.log(chalk.red(`Base app module is not initiated in this directory! Please first run "mssk base-module:init", or switch to a directory where base app module is already initiated!`))
    }


    let baseAppProperties: any;
    try {
      baseAppProperties = fs.readJsonSync('./mssk-properties.json')
    } catch (err) {
      return this.log("There was a problem while reading mssk properties file: " + chalk.red(err))
    }
    
    const environmentExists = fs.pathExistsSync(this.envDir(env))    
    if(environmentExists) {
      this.log(chalk.red(`environment "${env}" already exists in this directory!`))

      // yes/no confirmation
      const overwrite = await cli.confirm('Overwrite existing environment? (yes/no)')
      if (!overwrite) {
        return;
      }
    }

    this.log(`Environment "${env}" will be added...`)  
    const appName = baseAppProperties.appName
    const region = baseAppProperties.region
    const profile = baseAppProperties.profile

    // create directory for enviroment
    this.mkdirp(this.envDir(env), () => { 
      if(!baseAppProperties.environments) {
        baseAppProperties.environments = []
      }
      baseAppProperties.environments.push(env)

      // write the updated mssk properties file
      fs.writeJson(`./mssk-properties.json`, baseAppProperties, (err) => {
         if(err) {
            return this.log("There was a problem while updating mssk properties file: " + chalk.red(err))
          }

          this.log(chalk.green("mssk properties file updated!"))
      })

      const envMainFile = `${this.envDir(env)}/main.tf`
      // create terraform main file
      fs.writeFile(`${envMainFile}`, this.envModuleContent(appName, region, profile, env), (err) => {
        if(err) { 
          return this.log(`There was a problem creating the environment file "${envMainFile}" : ` + chalk.red(err.toString()))
        }
        this.log("Main class file - " + chalk.bold(envMainFile) + " -  " + chalk.green(`created with default configs! Please update the customizable configs in it as desired!`))
      })
    })
  }

  envDir(env: string) {
    return `./env-${env}`
  }

  envModuleContent(appName: string, region: string, profile: string, env: string) {
    return `
#############################################################################################################################
#
# Note: infrastructure metadata files (generated ssh keys,...etc.) will be generated intto ./meta_outputs
#
#############################################################################################################################


# Configure the AWS Provider as needed
provider "aws" {
  region = "${region}"
  profile = "${profile}"
}


module "base_app" {
  source = "../base_terraform_module"
  
  ##################
  ## AUTO Generated by MSSK! Do not manually configure!
  ##################
  # general app configurations
  app_name = "${appName}"
  environment = "${env}"
  ##################

  #####################
  # Customizable configurations (edit manually as desired)
  #####################

  # VPC configs
  vpc_configs = {
    vpc_cidr = "10.0.0.0/16"
    azs = ["${region}a", "${region}b"] # must be within the same region
    
    # the number of public and private subnets much match number of availability zones
    public_subnets_cidr = ["10.0.1.0/24", "10.0.2.0/24"]
    private_subnets_cidr = ["10.0.101.0/24", "10.0.102.0/24"]
  }

  # security group configs

  # public access to ALB! Should always be public since it's the main entry point for the system (internet facing). So it must always be 0.0.0.0/0 (= anywhere), 
  # unless you don't want the application to be publically reachable.
  alb_inbound_cidr_blocks = ["0.0.0.0/0"] 


  ### Consul settings
  consul_log_group_retention_in_days = 5
  consul_server_ec2_instance_type = "t2.micro"
  consul_server_asg_health_check_grace_period = 300 # seconds
  consul_server_asg_min_size = 1
  consul_server_asg_max_size = 3
  consul_server_asg_desired_capacity = 2
  consul_server_ec2_ssh_inbound_cidr_blocks = ["0.0.0.0/0"] # public SSH access to Consul ! Must be [] or specific IPs in production.
  consul_cluster_ec2_ports_external_cidr_blocks =  ["0.0.0.0/0"] # public access to the default Consul Server ports (8500, 8400...etc) through TCP and UDP! Must be [] or specific IPs in production.
}
`

  }

  mkdirp(path: string, successHandler = () => {}) {
    fs.mkdirp(path, (err) => {
      if(err) { 
        return this.log(`There was a problem creating folder "${path}": ` + chalk.red(err.toString()))
      }
      this.log("Folder - " + chalk.bold(path) + " -  " + chalk.green(`created!`))

      successHandler();
    })
  }
}
